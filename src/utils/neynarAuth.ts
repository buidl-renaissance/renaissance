/**
 * Neynar Sign In With Neynar (SIWN) Integration
 * 
 * This module provides a single sign-in flow that grants both:
 * - Identity (FID, username, profile)
 * - Write access (signer for posting)
 * 
 * Flow:
 * 1. Open Neynar auth URL
 * 2. User approves in browser/Farcaster
 * 3. Callback returns signer_uuid + fid
 * 4. Fetch full user profile
 * 5. Store auth data for future use
 */

import * as Linking from "expo-linking";
import * as SecureStore from "expo-secure-store";
import { Platform } from "react-native";
import { NEYNAR_API_KEY as ENV_NEYNAR_API_KEY } from "@env";

// Neynar API configuration
const NEYNAR_API_BASE = "https://api.neynar.com/v2/farcaster";
const NEYNAR_AUTH_URL = "https://app.neynar.com/login";

// Storage keys
const NEYNAR_SIGNER_UUID_KEY = "NEYNAR_SIGNER_UUID";
const NEYNAR_FID_KEY = "NEYNAR_FID";

// Get API key from environment
let NEYNAR_API_KEY = ENV_NEYNAR_API_KEY || "";

/**
 * Set the Neynar API key programmatically
 */
export function setNeynarApiKey(key: string): void {
  NEYNAR_API_KEY = key;
}

/**
 * Get the current API key
 */
export function getNeynarApiKey(): string {
  return NEYNAR_API_KEY;
}

export interface NeynarUser {
  fid: number;
  username: string;
  displayName: string;
  pfpUrl?: string;
  bio?: string;
  followerCount?: number;
  followingCount?: number;
  verifications?: string[];
  custodyAddress?: string;
}

export interface NeynarAuthResult {
  user: NeynarUser;
  signerUuid: string;
  isApproved: boolean;
}

// Store pending auth state
let pendingAuthResolve: ((result: NeynarAuthResult) => void) | null = null;
let pendingAuthReject: ((error: Error) => void) | null = null;

/**
 * Get the callback URL for Neynar auth
 */
function getCallbackUrl(): string {
  return Linking.createURL("auth/neynar");
}

/**
 * Initiate Neynar Sign In flow
 * Opens the Neynar auth page which handles signer creation and approval
 */
export async function initiateNeynarSignIn(
  clientId: string
): Promise<NeynarAuthResult> {
  console.log("[NeynarAuth] Starting SIWN flow...");

  const callbackUrl = getCallbackUrl();
  console.log("[NeynarAuth] Callback URL:", callbackUrl);

  // Build the Neynar auth URL
  // Neynar SIWN uses OAuth-style flow
  const authUrl = new URL(NEYNAR_AUTH_URL);
  authUrl.searchParams.set("client_id", clientId);
  authUrl.searchParams.set("redirect_uri", callbackUrl);
  authUrl.searchParams.set("response_type", "code");

  console.log("[NeynarAuth] Opening auth URL:", authUrl.toString());

  return new Promise(async (resolve, reject) => {
    pendingAuthResolve = resolve;
    pendingAuthReject = reject;

    try {
      // Prefer Farcaster app if available, otherwise fall back to system browser
      const canOpenFarcaster = await Linking.canOpenURL("farcaster://");

      if (canOpenFarcaster) {
        await Linking.openURL(authUrl.toString());
      } else {
        await Linking.openURL(authUrl.toString());
      }
      // NOTE: Callback handling is done via deep links and handleNeynarCallback.
      // The promise will be resolved/rejected when handleNeynarCallback runs.
    } catch (error) {
      console.error("[NeynarAuth] Auth error:", error);
      pendingAuthReject?.(error as Error);
      pendingAuthResolve = null;
      pendingAuthReject = null;
    }
  });
}

/**
 * Alternative: Create signer and get approval URL directly via API
 * This gives more control over the flow
 */
export async function createSignerAndGetApprovalUrl(): Promise<{
  signerUuid: string;
  approvalUrl: string;
  publicKey: string;
}> {
  console.log("[NeynarAuth] Creating signer via API...");

  // Step 1: Create a signer
  const createResponse = await fetch(`${NEYNAR_API_BASE}/signer`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "api_key": NEYNAR_API_KEY,
    },
  });

  if (!createResponse.ok) {
    const errorText = await createResponse.text();
    console.error("[NeynarAuth] Create signer error:", createResponse.status, errorText);
    throw new Error(`Failed to create signer: ${createResponse.status}`);
  }

  const signerData = await createResponse.json();
  console.log("[NeynarAuth] Signer created:", signerData);

  const { signer_uuid, public_key, status } = signerData;

  // Step 2: Get the approval URL
  // The approval URL is generated by Neynar for the user to approve
  const approvalUrl = `https://client.warpcast.com/deeplinks/signed-key-request?token=${signer_uuid}`;

  return {
    signerUuid: signer_uuid,
    approvalUrl,
    publicKey: public_key,
  };
}

/**
 * Initiate sign-in using direct API flow
 * Creates signer, opens Farcaster for approval, polls for completion
 */
export async function initiateDirectSignIn(): Promise<NeynarAuthResult> {
  console.log("[NeynarAuth] Starting direct sign-in flow...");

  try {
    // Create signer
    const { signerUuid, approvalUrl, publicKey } = await createSignerAndGetApprovalUrl();

    // Open Farcaster/Warpcast for approval
    const canOpenFarcaster = await Linking.canOpenURL("farcaster://");
    
    if (canOpenFarcaster) {
      // Try Farcaster deep link
      await Linking.openURL(approvalUrl);
    } else {
      // Fall back to system browser
      await Linking.openURL(approvalUrl);
    }

    // Poll for signer approval
    const result = await pollSignerStatus(signerUuid);

    if (!result.isApproved || !result.fid) {
      throw new Error("Signer was not approved");
    }

    // Fetch full user profile
    const user = await fetchUserProfile(result.fid);

    // Store the signer UUID
    await storeSignerData(signerUuid, result.fid);

    return {
      user,
      signerUuid,
      isApproved: true,
    };
  } catch (error) {
    console.error("[NeynarAuth] Direct sign-in error:", error);
    throw error;
  }
}

/**
 * Handle the callback from Neynar auth
 */
export async function handleNeynarCallback(url: string): Promise<void> {
  console.log("[NeynarAuth] Handling callback:", url);

  try {
    const parsedUrl = new URL(url);
    const params = parsedUrl.searchParams;

    // Extract the authorization code or signer data
    const code = params.get("code");
    const signerUuid = params.get("signer_uuid");
    const fid = params.get("fid");
    const error = params.get("error");

    if (error) {
      throw new Error(`Auth error: ${error}`);
    }

    let finalSignerUuid: string;
    let finalFid: number;

    if (signerUuid && fid) {
      // Direct callback with signer data
      finalSignerUuid = signerUuid;
      finalFid = parseInt(fid, 10);
    } else if (code) {
      // OAuth-style callback - exchange code for tokens
      const tokenResult = await exchangeCodeForTokens(code);
      finalSignerUuid = tokenResult.signerUuid;
      finalFid = tokenResult.fid;
    } else {
      throw new Error("Invalid callback - missing required parameters");
    }

    // Fetch user profile
    const user = await fetchUserProfile(finalFid);

    // Store signer data
    await storeSignerData(finalSignerUuid, finalFid);

    // Resolve the pending promise
    if (pendingAuthResolve) {
      pendingAuthResolve({
        user,
        signerUuid: finalSignerUuid,
        isApproved: true,
      });
      pendingAuthResolve = null;
      pendingAuthReject = null;
    }
  } catch (error) {
    console.error("[NeynarAuth] Callback error:", error);
    if (pendingAuthReject) {
      pendingAuthReject(error as Error);
      pendingAuthResolve = null;
      pendingAuthReject = null;
    }
  }
}

/**
 * Exchange authorization code for tokens (OAuth flow)
 */
async function exchangeCodeForTokens(code: string): Promise<{
  signerUuid: string;
  fid: number;
}> {
  // This would be implemented based on Neynar's OAuth flow
  // For now, this is a placeholder
  throw new Error("OAuth code exchange not yet implemented - use direct flow");
}

/**
 * Poll for signer approval status
 */
async function pollSignerStatus(
  signerUuid: string,
  maxAttempts = 60,
  intervalMs = 2000
): Promise<{ isApproved: boolean; fid?: number }> {
  console.log("[NeynarAuth] Polling signer status...");

  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    try {
      const response = await fetch(
        `${NEYNAR_API_BASE}/signer?signer_uuid=${signerUuid}`,
        {
          headers: {
            "api_key": NEYNAR_API_KEY,
          },
        }
      );

      if (!response.ok) {
        console.log("[NeynarAuth] Poll error:", response.status);
        await sleep(intervalMs);
        continue;
      }

      const data = await response.json();
      console.log("[NeynarAuth] Signer status:", data.status);

      if (data.status === "approved") {
        return {
          isApproved: true,
          fid: data.fid,
        };
      }

      if (data.status === "revoked") {
        return { isApproved: false };
      }

      // Still pending, continue polling
      await sleep(intervalMs);
    } catch (error) {
      console.error("[NeynarAuth] Poll error:", error);
      await sleep(intervalMs);
    }
  }

  throw new Error("Signer approval timed out");
}

/**
 * Fetch user profile from Neynar
 */
export async function fetchUserProfile(fid: number): Promise<NeynarUser> {
  console.log("[NeynarAuth] Fetching profile for FID:", fid);

  const response = await fetch(
    `${NEYNAR_API_BASE}/user/bulk?fids=${fid}`,
    {
      headers: {
        "api_key": NEYNAR_API_KEY,
      },
    }
  );

  if (!response.ok) {
    const errorText = await response.text();
    console.error("[NeynarAuth] Profile fetch error:", response.status, errorText);
    throw new Error(`Failed to fetch user profile: ${response.status}`);
  }

  const data = await response.json();
  const user = data.users?.[0];

  if (!user) {
    throw new Error("User not found");
  }

  return {
    fid: user.fid,
    username: user.username,
    displayName: user.display_name,
    pfpUrl: user.pfp_url,
    bio: user.profile?.bio?.text,
    followerCount: user.follower_count,
    followingCount: user.following_count,
    verifications: user.verifications,
    custodyAddress: user.custody_address,
  };
}

/**
 * Store signer data securely
 */
async function storeSignerData(signerUuid: string, fid: number): Promise<void> {
  await SecureStore.setItemAsync(NEYNAR_SIGNER_UUID_KEY, signerUuid);
  await SecureStore.setItemAsync(NEYNAR_FID_KEY, fid.toString());
}

/**
 * Get stored signer UUID
 */
export async function getStoredSignerUuid(): Promise<string | null> {
  return SecureStore.getItemAsync(NEYNAR_SIGNER_UUID_KEY);
}

/**
 * Get stored FID
 */
export async function getStoredFid(): Promise<number | null> {
  const fid = await SecureStore.getItemAsync(NEYNAR_FID_KEY);
  return fid ? parseInt(fid, 10) : null;
}

/**
 * Clear stored auth data
 */
export async function clearNeynarAuth(): Promise<void> {
  await SecureStore.deleteItemAsync(NEYNAR_SIGNER_UUID_KEY);
  await SecureStore.deleteItemAsync(NEYNAR_FID_KEY);
}

/**
 * Check if user has valid Neynar auth
 */
export async function hasValidNeynarAuth(): Promise<boolean> {
  const signerUuid = await getStoredSignerUuid();
  const fid = await getStoredFid();
  return signerUuid !== null && fid !== null;
}

/**
 * Post a cast using the stored signer
 */
export async function postCast(
  text: string,
  options?: {
    parentUrl?: string;
    parentHash?: string;
    embeds?: { url: string }[];
  }
): Promise<{ hash: string; success: boolean }> {
  const signerUuid = await getStoredSignerUuid();
  
  if (!signerUuid) {
    throw new Error("No signer available - please sign in first");
  }

  console.log("[NeynarAuth] Posting cast...");

  const response = await fetch(`${NEYNAR_API_BASE}/cast`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "api_key": NEYNAR_API_KEY,
    },
    body: JSON.stringify({
      signer_uuid: signerUuid,
      text,
      parent: options?.parentHash,
      channel_id: options?.parentUrl,
      embeds: options?.embeds,
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    console.error("[NeynarAuth] Post cast error:", response.status, errorText);
    throw new Error(`Failed to post cast: ${response.status}`);
  }

  const data = await response.json();
  console.log("[NeynarAuth] Cast posted:", data);

  return {
    hash: data.cast?.hash,
    success: true,
  };
}

/**
 * Sign a message using the Neynar signer
 * Used for mini app authentication
 */
export async function signMessage(message: string): Promise<string> {
  const signerUuid = await getStoredSignerUuid();
  
  if (!signerUuid) {
    throw new Error("No signer available - please sign in first");
  }

  // Neynar doesn't expose direct signing endpoint
  // For mini app auth, we may need to construct the signature differently
  // This is a placeholder that would need Neynar's signing API
  console.log("[NeynarAuth] Sign message requested - using signer:", signerUuid);
  
  throw new Error("Direct message signing not available via Neynar API");
}

/**
 * Cast interface matching Neynar API response
 */
export interface Cast {
  hash: string;
  author: {
    fid: number;
    username?: string;
    display_name?: string;
    pfp_url?: string;
  };
  text: string;
  timestamp: string;
  embeds?: Array<{
    url?: string;
    cast_id?: {
      fid: number;
      hash: string;
    };
  }>;
  reactions?: {
    likes_count?: number;
    recasts_count?: number;
    replies_count?: number;
  };
  parent_author?: {
    fid: number;
    username?: string;
  };
  parent_hash?: string;
}

/**
 * Fetch casts for a specific user (FID)
 */
export async function fetchUserCasts(
  fid: number,
  options?: {
    limit?: number;
    cursor?: string;
  }
): Promise<{ casts: Cast[]; next?: { cursor: string } }> {
  console.log("[NeynarAuth] Fetching casts for FID:", fid);

  const limit = options?.limit || 25;
  const params = new URLSearchParams({
    fid: fid.toString(),
    limit: limit.toString(),
  });

  if (options?.cursor) {
    params.append("cursor", options.cursor);
  }

  const response = await fetch(
    `${NEYNAR_API_BASE}/feed/user/casts?${params.toString()}`,
    {
      headers: {
        "api_key": NEYNAR_API_KEY,
      },
    }
  );

  if (!response.ok) {
    const errorText = await response.text();
    console.error("[NeynarAuth] Fetch casts error:", response.status, errorText);
    throw new Error(`Failed to fetch casts: ${response.status}`);
  }

  const data = await response.json();
  console.log("[NeynarAuth] Fetched casts:", data.result?.casts?.length || 0);

  return {
    casts: data.result?.casts || [],
    next: data.result?.next ? { cursor: data.result.next.cursor } : undefined,
  };
}

// Helper function
function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

export default {
  initiateNeynarSignIn,
  initiateDirectSignIn,
  handleNeynarCallback,
  fetchUserProfile,
  fetchUserCasts,
  getStoredSignerUuid,
  getStoredFid,
  clearNeynarAuth,
  hasValidNeynarAuth,
  postCast,
  setNeynarApiKey,
  getNeynarApiKey,
};


